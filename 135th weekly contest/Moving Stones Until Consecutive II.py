# -*-coding:utf-8-*-
class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        """
        此题的最终答案其实就是一个连续的n个序列
        不妨先考虑下界
            滑动一个大小为n的窗口，有多少stone已经在窗口内，现在想要将其他stone移动到窗口内，对每个这样的stone至少移动1次，一般来说，缺失几个就移动几次就可以最快到达目标，但是这题有个唯一的例外，必须将端点移动到非端点
        再考虑上界
            我们总是希望慢慢将所有的stone全部靠左或者靠右，如果单单看靠右的情况
            例如对于A[0]将其移动到A[1]+1（如果这是空位的话），也就是说，每次挑选左边的端点，将其移动到下一个stone的后一个空位，那么何时停止呢？其实只要最左侧的与最右侧的相差为n-1即A[n-1]-A[0]=n-1；若是希望尽量靠左，则将右边的所有石头尽量靠左。（这个想法的核心是源于端点不能移动到端点）
        """
        A = stones
        A.sort()
        n = len(A)
        high = max(A[-1] - A[1] - (n - 1) + 1, A[-2] - A[0] - (n - 1) + 1)  # 这里求了除左侧端点外所有点的空位或者是除右侧端点外所有点的空位，取两者较大者

        i, low = 0, n  # 假设一个也不再窗口内那么最多移动n次（当然，这只是一个更新的临界值）
        for j in range(n):
            while A[j] - A[i] >= n:  # 这一步找到了一个i，j指针标识的大小为n的窗口，后续就是讲窗口外面的拉进来
                i += 1
            if j - i + 1 == n - 1 and A[j] - A[i] == n - 2:
                low = min(low, 2)
            else:
                low = min(low, n - (j - i + 1))
        return [low, high]
