# 题解
## Special Positions in a Binary Matrix
很简单的送分题，确认某个元素为1之后，只要当前行和列的和为1，那么必然为特殊位置。

## Count Unhappy Friends
存在两个配对(x, y)和(u, v)， 若x比起y和u亲密度更高且u比起v和x亲密度更高，则认为这两个配对可以互相调整，也就是说他们都因为没有匹配到本该更好的人而unhappy的。
本题使用类似哈希的思路，维护一个字典，存放每个friend比当前配对更好的人的列表，遍历这个字典，只要key与value互相存在即可互换配对一次。

## Min Cost to Connect All Points
各点连接最小路径，其实就是最小连通图的求解过程，这里随机选择起始点，然后每次选择一个离当前点最近的点扩张，一种贪婪策略。

## Check If String Is Transformable With Substring Sort Operations
这道题必须首先明确一个事实，如果有两个字符`s[i`]和`s[j]`并且存在`i<j`，那么后面的那个字符可以自由移动到至多`s[i]`前面。所以本题不需要关心所谓的升序排序，只需要知道将字符左移能否到达目标字符串的位置即可。

通过两个列表idx和use来表示源串中各个字符的先后出现顺序的下标和各个字符的使用次数。对每个目标字符串中的字符，首先确认idx中剩余该字符是否足量，进而确认该字符前是否有比它更小的字符。